The Micronaut HTTP server supports applying filters to request/response processing in a similar (but reactive) way to Servlet filters in traditional Java applications.

Filters support the following use cases:

* Decoration of the incoming api:http.HttpRequest[]
* Modification of the outgoing api:http.HttpResponse[]
* Implementation of cross-cutting concerns such as security, tracing, etc.

There are two ways to implement a filter. There is the "old" (pre Micronaut HTTP 4.0) approach using api:http.filter.HttpServerFilter[] (or api:http.filter.HttpClientFilter[]), and the "new" way using declarative filter methods. This guide only describes the latter.

A filter method must be declared in a bean annotated with api:http.annotation.ServerFilter[], or api:http.annotation.ClientFilter[] if it should instead intercept requests made by the HTTP client. Each filter method must also be annotated with api:http.annotation.RequestFilter[], to run before the request is processed, or api:http.annotation.ResponseFilter[], to run after the request has completed to process the response.

A filter method can take various parameters, such as the api:http.HttpRequest[] and the api:http.HttpResponse[] (only for response filters). The return type can be `void` or an updated api:http.HttpRequest[] (only for request filters) or api:http.HttpResponse[]. The different supported parameter and return types are described in the documentation of api:http.annotation.RequestFilter[] and api:http.annotation.ResponseFilter[].

To write asynchronous filters, you can return a reactive publisher.

To put these concepts into practice lets look at an example.

IMPORTANT: Filters execute in the event loop by default. If you need to perform blocking operations, you can annotate the filter with api:scheduling.annotation.ExecuteOn[].

== Writing a Filter

Suppose you wish to trace each request to the Micronaut "Hello World" example using some external system. This system could be a database or a distributed tracing service, and may require I/O operations.

You should not block the underlying Netty event loop in your filter; instead the filter should proceed with execution once any I/O is complete.

As an example, consider this `TraceService` that uses https://projectreactor.io[Project Reactor] to compose an I/O operation:

snippet::io.micronaut.docs.server.filters.TraceService[tags="imports,class", indent=0, title="A TraceService Example using Reactive Streams"]

<1> Since this is just an example, the logic does nothing yet

You can then inject this implementation into your filter definition:

snippet::io.micronaut.docs.server.filters.TraceFilter[tags="imports,class,endclass", indent=0, title="An Example ServerFilter"]

<1> The api:http.annotation.ServerFilter[] annotation defines the URI pattern(s) the filter matches
<2> The previously defined `TraceService` is injected via constructor

The final step is to write the filter methods.

snippet::io.micronaut.docs.server.filters.TraceFilter[tags="doFilter", indent=0, title="The filter methods"]

<1> `TraceService` is invoked to trace the request
<2> The request filter is marked to execute on a separate thread so that the blocking code in `TraceService` does not cause problems
<3> Finally, a separate response filter method adds a `X-Trace-Enabled` header to the response.

The previous example demonstrates some key concepts such as executing blocking logic in a worker thread before proceeding with the request and modifying the outgoing response.

Filter patterns can be defined on the filter class (in the api:http.annotation.ServerFilter[] or api:http.annotation.ClientFilter[] annotation), or on the filter method (in the api:http.annotation.RequestFilter[] or api:http.annotation.ResponseFilter[] annotation). You can use different styles of pattern for path matching by setting `patternStyle`. By default, api:core.util.AntPathMatcher[] is used for path matching. When using Ant, the mapping matches URLs using the following rules:

* ? matches one character
* * matches zero or more characters
* ** matches zero or more subdirectories in a path

.@Filter Annotation Path Matching Examples
|===
|Pattern|Example Matched Paths

|`/**`
|any path

|`customer/j?y`
|customer/joy, customer/jay

|`customer/*/id`
|customer/adam/id, com/amy/id

|`customer/**`
|customer/adam, customer/adam/id, customer/adam/name

|`customer/**/*.html`
|customer/index.html, customer/adam/profile.html, customer/adam/job/description.html

The other option is regular expression based matching. To use regular expressions, set `patternStyle = FilterPatternStyle.REGEX`. The `pattern` attribute is expected to contain a regular expression which will be expected to match the provided URLs exactly (using link:{jdkapi}/java/util/regex/Matcher.html#matches--[Matcher#matches]).

NOTE: Using `FilterPatternStyle.ANT` is preferred as the pattern matching is more performant than using regular expressions. `FilterPatternStyle.REGEX` should be used when your pattern cannot be written properly using Ant.

== Continuations

Request filters can define a special api:http.filter.FilterContinuation[] parameter to get more control of the downstream execution, and to be run further actions after it completes. For example, the above `TraceFilter` can be expressed using a single request filter:

snippet::io.micronaut.docs.server.filters.TraceFilter2[tags="doFilter", indent=0, title="Single request filter"]

<1> The request filter declares a api:http.filter.FilterContinuation[] parameter. The continuation will return a api:http.MutableHttpResponse[]
<2> After the request processing is done, the filter calls the blocking `proceed` to run downstream filters and the controller
<3> When downstream processing completes, the filter adds a `X-Trace-Enabled` header to the response returned by the continuation
<4> The whole filter is executed on a worker thread to avoid blocking the event loop in the `proceed` call

IMPORTANT: The call to `FilterContinuation.proceed` is blocking by default, so it should never be done on the event loop. Such filters should be run on a worker thread as described above. Alternatively, the continuation can also be declared to return a reactive type (`Publisher<HttpResponse<?>>`) to proceed in an asynchronous manner, similar to the old api:http.filter.FilterChain[] API.

== Error States

In principle, downstream filters and controllers can produce exceptions, and response filters should be prepared to handle them. For a response filter to be called when there is an exception, it must declare the exception type as a parameter.

.@Filter Response filter declaration
|===
|Declaration|Called when?

|`void responseFilter(HttpResponse<?> response)`
|Only called on non-exception response

|`void responseFilter(Throwable failure)`
|Only called on exception response

|`void responseFilter(IOException failure)`
|Only called on exception response, if the exception is an `IOException`

|`void responseFilter(HttpResponse<?> response, @Nullable Throwable failure)`
|Always called. `failure` will be `null` if there was no error. If there was an error, `response` will be `null`.

Whether errors appear as exceptions depends on the context of the filter. For the Micronaut HTTP server, any exception is mapped to a non-exceptional api:http.HttpResponse[] with an error status code. This mapping happens before each filter, so a server filter will never actually see an exception. If you still want to access the original cause of the response, it is stored as the attribute api:http.HttpAttributes#EXCEPTION[].
